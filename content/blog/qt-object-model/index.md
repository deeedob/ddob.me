+++
title = "The Qt Object Model"
date = 2025-10-30
draft = true
[taxonomies]
tags=["Qt"]
[extra]
image_position="10%"
+++
{{ codemirror_load(path="src/main.cpp", language="cpp", key="main") }}

Usually, when working with Qt the direct interaction with its very core functionality is not
required that often. We software developers like to abstract things. I would even say it's part of
our job identity - taking complex structures and problems and breaking them down into digestable
sections. We usually end up living in those abstracted worlds, with our memories of the underlying
systems fading away if not reminded from time to time.

Systems grow like trees, and even the most outer leaf will have full dependency on its roots
functionality. In this post I will try to peel the layers back and try to show my representation of
the most important things.

If an application runs for a longer period, it will hopefully not spend hours calculating a
Fibonacci sequence, but rather react to something: incoming data, user input, or external signals.

When creating GUI applications, modularity, flexibility, and reactivity become essential
cornerstones of the development workflow. But even long-running, non-graphical applications — such
as services or background processes can benefit from the same properties.

The Qt Object Model provides the central mechanism for this communication. `QObject` is the base
class that encapsulates and manages these core features. It is so fundamental to the Qt ecosystem
that it’s worth examining it more closely.

Let’s start by creating a simple custom object:

{{ codemirror(key="main", section="task") }}

Let’s go through this code step by step.

First of all, it’s important to understand that the [Meta-Object Compiler (moc)](https://doc.qt.io/qt-6/moc.html) must be run for every `QObject` subclass.

The `Q_OBJECT` macro instructs *moc* to generate meta-object information for this class, enabling features like signals, slots, and runtime introspection. This macro is **required** for any class deriving from QObject.

The constructor takes a `QObject* parent = nullptr`. This parent-defaulting pattern is very common and enables Qt’s **Object Trees & Ownership** mechanism.

`Q_DISABLE_COPY_MOVE_X` (or `Q_DISABLE_COPY_MOVE`) is strongly recommended to make it immediately clear that this class should not be copied or moved. QObjects are treated as identities, not value types, so copying or moving them would break that assumption. Any subclass therefore also inherits this restriction.

The `finished` signal is listed under the `signals:` section. The Meta-Object Compiler will generate its implementation automatically.

The `start` function is declared under `public slots:`. A slot is a normal C++ function and can be called directly. Its special property is that it can be connected to a signal. Inside it, we call the `finished` function using the `emit` keyword. While `emit` expands to nothing at compile time, it’s strongly recommended to use it to make the intent clear — that this call triggers a signal emission.

Lastly, we include `main.moc`, which gets generated by moc.
It contains the generated meta-object data, including the `staticMetaObject` definition and the code for the `finished` signal.

```cpp
// SIGNAL 0
void Task::finished()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}
```

## Meta Objects

Reflection refers to the ability of a program to inspect and manipulate its own structure at runtime — for example, by discovering a class name, its properties, or methods without hardcoding them.

The C++ standard will gain this capability with [P2996: Reflection for C++26](https://wg21.link/p2996), but such functionality has long been available in Qt through its meta-object system.

This enables loose coupling and greatly simplifies event-driven programming. With this reflective layer, we can operate on objects at a very generic level while still keeping full flexibility and type safety.

{{ codemirror(key="main", section="processor") }}

The `genericObjectProcessor` function shows how to interact with `QObject` instances in a generic way using Qt’s meta-object system.
It looks up signals and slots by name and can connect or invoke them without knowing the concrete type. The `connectionType` argument determines how signals are dispatched to slots.

{% note_box(type="info", title="Qt Connection Types") %}
`Qt::AutoConnection` — **(default)** If the sender and receiver live in the same thread, it behaves like **DirectConnection**; otherwise, it behaves like **QueuedConnection**.

`Qt::DirectConnection` — The slot is invoked synchronously in the thread that emits the signal.

`Qt::QueuedConnection` — The slot is invoked asynchronously via the event loop of the receiver’s thread.
{% end %}

For cases where a specific type needs to be handled, `qobject_cast` is used.
It provides a fast way to downcast a `QObject` without the overhead of C++ Run-Time Type Information (RTTI) or `dynamic_cast`, and works reliably across libraries.

In this processor, it is used to detect a `QThread` and shut down the thread cleanly.

Our `Task` class is a suitable candidate for `genericObjectProcessor`.
The processor calls its `start` slot and connects to the `finished` signal.

{{ codemirror(key="main", section="processor-task") }}

{% code_detail(title="Running Task") %}
Generic processor on object class:  "Task"
started Task { name:  task-1 , created: QDateTime(2025-10-19 09:07:42.275 UTC Qt::UTC) }
  finished() emitted on class:  "Task"
{% end %}

But since our processor is generic and simply accepts the base QObject class, we could
also pass in some other class, like a `QThread`, which happens to also have a `start` slot
and `finished` signal.

{{ codemirror(key="main", section="processor-thread") }}

{% code_detail(title="Running QThread") %}
Generic processor on object class:  "QThread"
thread started
  finished() emitted on class:  "QThread"
{% end %}

Because `QThread` has its own thread affinity, an explicit `Qt::DirectConnection` is required to execute this without an event loop.

Timers are another candidate for the processor. They do not have a `finished` signal but do have a `start` slot.

{{ codemirror(key="main", section="processor-timer") }}

{% code_detail(title="Running Timers") %}
Generic processor on object class:  "QTimer"
QTimer timeout

Generic processor on object class:  "QChronoTimer"
QChronoTimer timeout
{% end %}

Here we create a `QTimer` and a `QChronoTimer`, which have similar APIs, and set up the signal-slot connections using a small helper lambda.

For timers, `Qt::DirectConnection` alone is not sufficient. After calling `genericObjectProcessor`, we need to process the event loop manually.
Calling `app.processEvents()` ensures all pending events are executed.

---

Directly interacting with the meta-object system is not required frequently in most applications.
However, since this mechanism underlies the entire Qt library, it provides a level of flexibility that is always at your fingertips when needed.

You can inspect objects at runtime, query and invoke signals or slots, and respond to their behavior without knowing their concrete type.
This makes it possible to build generic systems, such as processors for any `QObject` subclass, dynamic GUIs that adapt to object properties, or event-routing frameworks that connect signals and slots across modules without tight coupling.
Even for logging, monitoring, or testing, the meta-object system enables automatic observation of object activity without modifying the classes themselves.

## Object Trees & Ownership

Many Qt classes derive from `QObject`, which provides a built-in mechanism for managing object lifetimes through parent–child relationships.
When an object is given a parent, it becomes part of that parent’s internal object tree.
This structure ensures that when a parent is destroyed, all of its children are deleted automatically.

This ownership system is simple but fundamental. It eliminates the need for manual memory management in most cases and prevents common issues such as leaks and dangling pointers.
Creating a child object is straightforward: pass the parent pointer to the constructor. Qt will then take care of destruction order and ownership tracking.

Let’s see this in practice.

{{ codemirror(key="main", section="qt-lifetime") }}
{% code_detail(title="Outputs") %}
Before scope: subtask1=0x1f4f8e0e0, subtask2=0x0
QObject(0x16f6565f8, name = "todo-list") destroyed. Starting any remaining children:
started Task { name:  subtask1 , created: QDateTime(2025-10-19 22:45:51.907 UTC Qt::UTC) }
started Task { name:  task-1 , created: QDateTime(2025-10-19 22:45:51.907 UTC Qt::UTC) }
started Task { name:  task-2 , created: QDateTime(2025-10-19 22:45:51.907 UTC Qt::UTC) }
started Task { name:  subtask2 , created: QDateTime(2025-10-19 22:45:51.907 UTC Qt::UTC) }
started Task { name:  task-3 , created: QDateTime(2025-10-19 22:45:51.907 UTC Qt::UTC) }
started Task { name:  task-4 , created: QDateTime(2025-10-19 22:45:51.907 UTC Qt::UTC) }
After scope:  subtask1=0x717450030, subtask2=0x0
{% end %}

Here we build a small tree of `Task` objects. The root `todoList` has two children, `subtask1` and
`subtask2`. Each of those subtasks owns two more tasks.

When `todoList` goes out of scope, it emits the `destroyed` signal. In our example, we connect to
this signal to recursively traverse all children and call their `start()` slots before they are
deleted.

{% note_box(type="info", title="QObject::destroyed") %}
The `destroyed(QObject *obj)` signal is emitted just before `obj` is deleted.
At this point, the `obj` pointer is still valid, but its base-class destructors have already run, so accessing derived members is **unsafe**.
All child objects are destroyed **immediately after** this signal is emitted.
{% end %}

I hope you have spotted the subtle but critical bugs in our code.
Everything is properly deleted through the parent–child relationship, but our usage of the raw `Task*` pointer is flawed.

We never set or reset the pointer to `nullptr`. If another part of the application tries to access
`subtask1`, it will point to invalid memory. A classic dangling pointer:

```cpp
if (subtask1)
    subtask1->start(); // most probably crashes
```

This kind of bug is notoriously hard to track down. It’s exactly the sort of problem that both modern C++ and Qt’s object model aim to prevent.

{% note_box(type="warning", title="Dangling Pointers and QPointer") %}
A raw pointer becomes **dangling** once its object is deleted.
`QPointer` automatically turns `nullptr` when the target `QObject` is destroyed, preventing access to freed memory.
{% end %}

When working with `QObject`s, prefer to express ownership clearly. Only use raw pointers for non-owning references that are short-lived or wrapped in a `QPointer`.

{% note_box(type="info", title="Ownership Guidelines") %}
- Use **RAII** for all `QObject`s.
- Create on the **stack** or use smart pointers.
- Only call `new` if the object has a **parent** — otherwise, let RAII handle it.
{% end %}

## Events & Timers

In this section we'll have a look at the underlying system....
Events in Qt are another fundamental way to communicate and greatly improve
the flexibility of reactive applications. <TODO: explain a bit more, OS events, network events, internal
events, mouse blicks, keyboards?>
wraps internal events & system events
Most event handling in Qt is done autoamatically 'behind the curtains', or done implicitly
in things like `QWidget::update`.

To receive events, a `QObject` subclass can override the `virtual bool event(QEvent *e)` function. In this function you should return `true` if the event got accepted by the class
or return `false` otherwise. This will let `QCoreApplication::notify`, which drives the event delivery, know how to continue after the event got delivery.

Events can be sent synchronously through `bool QCoreApplication::sendEvent(~)`, which directly sends the
event to the object or go through the event system with `void QCoreApplication::postEvent(~)`, which makes
it asynchronous.

We will subclass our `Task` object and create an `EventTask` which overrides the `event` method.

{{ codemirror(key="main", section="eventTask") }}

Our custom event handler does some very basic filtering:
- If the `QEvent::Type` value is less then what we set we ignore it
- If the type matches, we request the application `qApp` to quit.
- Otherwise we propagate the event to the children.

Note that `qApp`, same as `qGuiApp` is a helper macro, which expands into
`QCoreApplication::instance()` (or a casted version of it).

{% note_box(type="info", title="Qt Applications") %}
- Qt applications are static and therefore globally accessible.
- They provide the Event Loop and Event Handling.
- `exec` enters the blocking event loop to process all events.
{% end %}

In our main we create a small hierarchy of `EventTask`s, and then
use `postEvent` to sent an event to the `parent` asynchronously.

`QEvent` has reserved everything above the `QEvent::User` type to be custom.

{{ codemirror(key="main", section="qt-events") }}
{% code_detail(title="Outputs") %}
Qt Events Start
Task "event-task-0" received: QEvent::ChildAdded
Task "event-task-0" received: QEvent::ChildAdded
Posting custom: QEvent::Type(1001)
Task "event-task-0" received: QEvent::Type(1001)
Task "event-task-1000" received: QEvent::Type(1001)
Task "event-task-1001" received: QEvent::Type(1001)
aboutToQuit
Qt Events End

{% end %}

---

Our parent first receives two `ChildAdded` events. He propages those
but our children, which got a type of `1000` and `1001` reject it immediately.

We then asynchronously post an event of custom type `1001`, which bubbles up
the children until the last child sends a synchronous `Quit` event to the application,
which lets `exec()` return .. and the applications quits.

### Timers

Timer functionality is centrally provided inside `Object` already. For most
timing functionality you would perhaps use explicit things such as a `QTimer` but It build its functionality on the same basis.

{{ codemirror(key="main", section="qt-event-timers") }}

{% code_detail(title="Outputs") %}
Qt Event Timers Start
Task "event-task-0" received: QEvent::ChildAdded
Start Time QTime("12:37:43.202")
Task "event-task-0" received: QEvent::Timer
Task "event-task-1" received: QEvent::Timer
Quit Time QTime("12:37:45.293")
Task "event-task-0" received: QEvent::Timer
Task "event-task-1" received: QEvent::Timer
Quit Time QTime("12:37:47.293")
Task "event-task-0" received: QEvent::Timer
Task "event-task-1" received: QEvent::Timer
Qt Event Timers End
{% end %}
